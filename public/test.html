<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Solana Crash Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.js"></script>
  <script src="https://unpkg.com/@coral-xyz/anchor@0.30.1/dist/browser/index.js"></script>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center">
  <div class="container mx-auto p-4 max-w-2xl">
    <h1 class="text-3xl font-bold mb-6 text-center">Solana Crash Game</h1>
    
    <!-- Wallet Connection -->
    <div id="wallet-section" class="mb-6">
      <button id="connect-wallet" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
        Connect Wallet
      </button>
      <p id="wallet-address" class="mt-2 text-sm"></p>
    </div>

    <!-- Game Initialization -->
    <div id="init-game-section" class="mb-6">
      <h2 class="text-xl font-semibold mb-2">Initialize Game</h2>
      <input id="max-players" type="number" min="1" max="255" placeholder="Max Players" class="bg-gray-800 text-white p-2 rounded mr-2">
      <button id="init-game" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">
        Initialize Game
      </button>
    </div>

    <!-- Place Bet -->
    <div id="bet-section" class="mb-6">
      <h2 class="text-xl font-semibold mb-2">Place Bet</h2>
      <input id="bet-amount" type="number" min="0.01" step="0.01" placeholder="Bet Amount (SOL)" class="bg-gray-800 text-white p-2 rounded mr-2">
      <button id="place-bet" class="bg-yellow-500 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded">
        Place Bet
      </button>
    </div>

    <!-- Cash Out -->
    <div id="cashout-section" class="mb-6">
      <h2 class="text-xl font-semibold mb-2">Cash Out</h2>
      <input id="cashout-multiplier" type="number" min="1" step="0.1" placeholder="Multiplier (e.g., 2.0)" class="bg-gray-800 text-white p-2 rounded mr-2">
      <button id="cash-out" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">
        Cash Out
      </button>
    </div>

    <!-- Game Status -->
    <div id="game-status" class="mb-6">
      <h2 class="text-xl font-semibold mb-2">Game Status</h2>
      <p id="game-active" class="text-sm"></p>
      <p id="current-players" class="text-sm"></p>
      <p id="current-multiplier" class="text-sm"></p>
      <p id="escrow-balance" class="text-sm"></p>
      <div id="crash-animation" class="mt-4 h-20 bg-gray-800 rounded"></div>
    </div>

    <!-- Start/End Game (Authority Only) -->
    <div id="admin-section" class="mb-6">
      <h2 class="text-xl font-semibold mb-2">Admin Controls</h2>
      <input id="crash-point" type="number" min="1" step="0.1" placeholder="Crash Point (e.g., 5.0)" class="bg-gray-800 text-white p-2 rounded mr-2">
      <button id="start-game" class="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded mr-2">
        Start Game
      </button>
      <button id="end-game" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">
        End Game
      </button>
    </div>

    <p id="error-message" class="text-red-500 text-sm"></p>
  </div>

  <script>
    const { Connection, PublicKey, SystemProgram, Transaction } = solanaWeb3;
    const { AnchorProvider, Program, web3 } = anchor;

    const PROGRAM_ID = new PublicKey("4JnQm2avRVzUsB2yji4NWER4QVYoQdJtQ4Zy7njMk9Zs");
    const connection = new Connection("https://api.devnet.solana.com", "confirmed");
    let provider, program, wallet;

    async function connectWallet() {
      try {
        if (window.solana && window.solana.isPhantom) {
          await window.solana.connect();
          wallet = window.solana;
          provider = new AnchorProvider(connection, wallet, { commitment: "confirmed" });
          const idl = await Program.fetchIdl(PROGRAM_ID, provider);
          program = new Program(idl, PROGRAM_ID, provider);
          document.getElementById("wallet-address").innerText = `Connected: ${wallet.publicKey.toString()}`;
          document.getElementById("connect-wallet").disabled = true;
          updateGameStatus();
        } else {
          showError("Please install Phantom Wallet");
        }
      } catch (err) {
        showError("Failed to connect wallet: " + err.message);
      }
    }

    async function initializeGame() {
      if (!program) return showError("Wallet not connected");
      const maxPlayers = parseInt(document.getElementById("max-players").value);
      if (!maxPlayers || maxPlayers < 1 || maxPlayers > 255) return showError("Invalid max players");

      const game = web3.Keypair.generate();
      try {
        await program.methods
          .initializeGame(maxPlayers)
          .accounts({
            game: game.publicKey,
            authority: wallet.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([game])
          .rpc();
        showError("Game initialized successfully");
        updateGameStatus();
      } catch (err) {
        showError("Failed to initialize game: " + err.message);
      }
    }

    async function placeBet() {
      if (!program) return showError("Wallet not connected");
      const amount = parseFloat(document.getElementById("bet-amount").value);
      if (!amount || amount <= 0) return showError("Invalid bet amount");

      const game = await findGamePda();
      const bet = await findBetPda(game, wallet.publicKey);
      const escrow = await findEscrowPda(game);

      try {
        await program.methods
          .placeBet(Math.floor(amount * 1e9)) // Convert SOL to lamports
          .accounts({
            game,
            bet,
            player: wallet.publicKey,
            escrow,
            systemProgram: SystemProgram.programId,
          })
          .rpc();
        showError("Bet placed successfully");
        updateGameStatus();
      } catch (err) {
        showError("Failed to place bet: " + err.message);
      }
    }

    async function cashOut() {
      if (!program) return showError("Wallet not connected");
      const multiplier = parseFloat(document.getElementById("cashout-multiplier").value);
      if (!multiplier || multiplier < 1) return showError("Invalid multiplier");

      const game = await findGamePda();
      const bet = await findBetPda(game, wallet.publicKey);
      const escrow = await findEscrowPda(game);

      try {
        await program.methods
          .cashOut(Math.floor(multiplier * 100)) // Convert to integer (e.g., 2.0 -> 200)
          .accounts({
            game,
            bet,
            player: wallet.publicKey,
            escrow,
            authority: wallet.publicKey, // Assuming player is authority for simplicity
          })
          .rpc();
        showError("Cashed out successfully");
        updateGameStatus();
      } catch (err) {
        showError("Failed to cash out: " + err.message);
      }
    }

    async function startGame() {
      if (!program) return showError("Wallet not connected");
      const crashPoint = parseFloat(document.getElementById("crash-point").value);
      if (!crashPoint || crashPoint < 1) return showError("Invalid crash point");

      const game = await findGamePda();
      try {
        await program.methods
          .startGame(Math.floor(crashPoint * 100))
          .accounts({
            game,
            authority: wallet.publicKey,
          })
          .rpc();
        showError("Game started successfully");
        animateCrash();
        updateGameStatus();
      } catch (err) {
        showError("Failed to start game: " + err.message);
      }
    }

    async function endGame() {
      if (!program) return showError("Wallet not connected");
      const game = await findGamePda();
      try {
        await program.methods
          .endGame()
          .accounts({
            game,
            authority: wallet.publicKey,
          })
          .rpc();
        showError("Game ended successfully");
        updateGameStatus();
      } catch (err) {
        showError("Failed to end game: " + err.message);
      }
    }

    async function findGamePda() {
      const [gamePda] = await PublicKey.findProgramAddress(
        [Buffer.from("game"), wallet.publicKey.toBuffer()],
        PROGRAM_ID
      );
      return gamePda;
    }

    async function findBetPda(game, player) {
      const [betPda] = await PublicKey.findProgramAddress(
        [Buffer.from("bet"), game.toBuffer(), player.toBuffer()],
        PROGRAM_ID
      );
      return betPda;
    }

    async function findEscrowPda(game) {
      const [escrowPda] = await PublicKey.findProgramAddress(
        [Buffer.from("escrow"), game.toBuffer()],
        PROGRAM_ID
      );
      return escrowPda;
    }

    async function updateGameStatus() {
      if (!program) return;
      try {
        const game = await findGamePda();
        const gameState = await program.account.game.fetch(game);
        document.getElementById("game-active").innerText = `Active: ${gameState.isActive}`;
        document.getElementById("current-players").innerText = `Current Players: ${gameState.currentPlayers}/${gameState.maxPlayers}`;
        document.getElementById("current-multiplier").innerText = `Current Multiplier: ${(gameState.multiplier / 100).toFixed(2)}x`;

        const escrow = await findEscrowPda(game);
        const escrowState = await program.account.escrow.fetch(escrow);
        document.getElementById("escrow-balance").innerText = `Escrow Balance: ${(escrowState.escrowBalance / 1e9).toFixed(2)} SOL`;
      } catch (err) {
        showError("Failed to fetch game status: " + err.message);
      }
    }

    function animateCrash() {
      const crashDiv = document.getElementById("crash-animation");
      let multiplier = 1;
      const interval = setInterval(() => {
        multiplier += 0.1;
        crashDiv.innerText = `Multiplier: ${multiplier.toFixed(2)}x`;
        crashDiv.style.background = `linear-gradient(to right, #4ade80 ${Math.min(multiplier * 10, 100)}%, #1f2937 0%)`;
        if (multiplier >= 10) clearInterval(interval); // Arbitrary stop for demo
      }, 100);
    }

    function showError(message) {
      const errorDiv = document.getElementById("error-message");
      errorDiv.innerText = message;
      setTimeout(() => (errorDiv.innerText = ""), 5000);
    }

    document.getElementById("connect-wallet").addEventListener("click", connectWallet);
    document.getElementById("init-game").addEventListener("click", initializeGame);
    document.getElementById("place-bet").addEventListener("click", placeBet);
    document.getElementById("cash-out").addEventListener("click", cashOut);
    document.getElementById("start-game").addEventListener("click", startGame);
    document.getElementById("end-game").addEventListener("click", endGame);
  </script>
</body>
</html>